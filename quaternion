#![forbid(unsafe_code)]

use std::fmt::{Display};
use std::ops::{Add, Mul, Sub, Div, Neg};
use num_traits::{Zero, One, Float};

#[derive(Debug, Clone)]
pub struct Quaternion<T> {
    w: T,
    x: T,
    y: T,
    z: T
}

impl<T> Quaternion<T> {
    pub fn new(w: T, x: T, y: T, z: T) -> Self {
        Quaternion { w, x, y, z }
    }
}

impl<T> Add for &Quaternion<T>
where
    T: Add<Output = T> + Copy{
    type Output = Quaternion<T>;
    fn add(self, rhs: &Quaternion<T>) -> Quaternion<T> {
        Quaternion{
            w: self.w + rhs.w,
            x: self.x + rhs.x,
            y: self.y + rhs.y,
            z: self.z + rhs.z
        }
    }
}

impl<T> Sub for & Quaternion<T>
where
    T: Sub<Output = T> + Copy{
    type Output = Quaternion<T>;
    fn sub(self, rhs: &Quaternion<T>) -> Quaternion<T> {
        Quaternion{
            w: self.w - rhs.w,
            x: self.x - rhs.x,
            y: self.y - rhs.y,
            z: self.z - rhs.z
        }
    }
}

impl<T> Mul for &Quaternion<T>
where
    T: Add<Output = T> + Sub<Output = T> + Mul<Output = T> + Copy{
    type Output = Quaternion<T>;
    fn mul(self, rhs: &Quaternion<T>) -> Quaternion<T> {
        Quaternion {
            w: self.w * rhs.w - self.x * rhs.x - self.y * rhs.y - self.z * rhs.z,
            x: self.w * rhs.x + self.x * rhs.w + self.y * rhs.z - self.z * rhs.y,
            y: self.w * rhs.y - self.x * rhs.z + self.y * rhs.w + self.z * rhs.x,
            z: self.w * rhs.z + self.x * rhs.y - self.y * rhs.x + self.z * rhs.w
        }
    }
}

impl<T> Mul<T> for &Quaternion<T>
where
    T: Mul<Output = T> + Copy{
    type Output = Quaternion<T>;
    fn mul(self, scalar:T) -> Quaternion<T> {
        Quaternion{
            w: self.w * scalar,
            x: self.x * scalar,
            y: self.y * scalar,
            z: self.z * scalar
        }
    }
}

impl<T> Div<T> for &Quaternion<T>
where
    T: Div<Output = T> + Copy{
    type Output = Quaternion<T>;
    fn div(self, scalar:T) -> Quaternion<T> {
        Quaternion{
            w: self.w / scalar,
            x: self.x / scalar,
            y: self.y / scalar,
            z: self.z / scalar
        }
    }
}

impl<T> Quaternion<T>
where
    T: Add<Output = T> + Sub<Output = T> + Mul<Output = T> + Neg<Output = T> +
       Zero + One +  Copy + Display{
    pub fn dot(self, other: &Quaternion<T>) -> T {
        self.w * other.w + self.x * other.x + self.y * other.y + self.z * other.z
    }

    pub fn dot_v(&self, other: &Quaternion<T>) -> Result<T, String> {
        if self.w.is_zero()  || other.w.is_zero(){
            Err(format!("Quaternion {} + {}i +{}j + {}k could not represent a vector.",
                        self.w, self.x, self.y, self.z))
        } else {
            Ok(self.w * other.w + self.x * other.x + self.y * other.y + self.z * other.z)
        }
    }

    pub fn conjugate(&self) -> Quaternion<T> {
        Quaternion{
            w: self.w,
            x: - self.x,
            y: - self.y,
            z: - self.z
        }
    }

    pub fn mat(&self) -> [[T; 3]; 3] {
        let w = self.w;
        let x = self.x;
        let y = self.y;
        let z = self.z;
        [[w * w + x * x - y * y - z * z,
          x * y + x * y - w * z - w * z,
          x * z + w * z + w * y + w * y],
         [x * y + x * y + w * z + w * z,
          w * w - x * x + y * y - z * z,
          y * z + y * z - w * x - w * x],
         [x * z + x * z - w * y - w * y,
          y * z + y * z + w * x + w * x,
          w * w - x * x - y * y + z * z]]
    }

    pub fn mat_homogeneous(&self) -> [[T; 4]; 4] {
        let w = self.w;
        let x = self.x;
        let y = self.y;
        let z = self.z;
        [[w * w + x * x - y * y - z * z,
          x * y + x * y - w * z - w * z,
          x * z + w * z + w * y + w * y, T::zero()],
         [x * y + x * y + w * z + w * z,
          w * w - x * x + y * y - z * z,
          y * z + y * z - w * x - w * x, T::zero()],
         [x * z + x * z - w * y - w * y,
          y * z + y * z + w * x + w * x,
          w * w - x * x - y * y + z * z, T::zero()],
         [T::zero(), T::zero(), T::zero(), T::one()]]
    }

    pub fn display(&self) -> String {
        format!("{} + {}i + {}j + {}k", self.w, self.x, self.y, self.z)
    }
}

impl<T> Quaternion<T>
where
    T: Float + Display{

    pub fn norm(&self) -> T {
        (self.w * self.w + self.x * self.x + self.y * self.y + self.z * self.z).sqrt()
    }

    pub fn normalize(&self) -> Result<Quaternion<T>, String> {
        let x = self.x;
        let y = self.y;
        let z = self.z;
        let w = self.w;
        let norm = self.norm();
        if norm == T::zero() {
            Err("Normalize: Cannot divide by zero".to_string())
        } else {
            Ok(Quaternion::new(w / norm, x / norm, y / norm, z / norm))
        }
    }

    pub fn rotate(&self, axis: &Quaternion<T>, angle: T) -> Result<Quaternion<T>, String> {
        if axis.w == T::zero() {
            Err("Rotate axis is not a vector".to_string())
        } else {
            let half_angle = angle / T::from(2).unwrap();
            let sine = half_angle.sin();
            let rotation_quaternion = Quaternion{
                w: half_angle.cos(),
                x: sine * axis.x,
                y: sine * axis.y,
                z: sine * axis.z};
            Ok(&(&rotation_quaternion * self) * &rotation_quaternion.conjugate())
        }
    }

    pub fn nlerp(&self, target: &Self, t: T) -> Result<Quaternion<T>, String> {
        let norm =  (&(self * (T::one() - t)) + &(target * t)).norm();
        if norm == T::zero() {
            Err("Nlerp: Cannot divide by zero!".to_string())
        } else {
            Ok(&(&(self * (T::one() - t)) + &(target * t)) / norm)
        }
    }

     pub fn slerp(&self, target: &Quaternion<T>, t: T) -> Result<Quaternion<T>, String> {
         let cosine = self.dot_v(target);
         match cosine {
             Ok(cosine) => {
                 let cosine = if cosine < T::zero() { -cosine } else { cosine };
                 if cosine >= T::from(0.9998).unwrap() {
                     Err("Slerp: cosine too small".to_string())
                 } else {
                     let angle = cosine.acos();
                     Ok(&(&(self * ((T::one() - t) * angle).sin()) +
                         &(target * (t * angle).sin())) / angle.sin())
                 }
             }
             Err(msg) => Err(msg)
         }
     }

    pub fn squad(&self, q1: &Quaternion<T>, q2: &Quaternion<T>, q3: &Quaternion<T>, t:T)
        -> Result<Quaternion<T>, String> {
        let m1 = self.slerp(&q3, t);
        let m2 = q1.slerp(&q2, t);
        match m1{
            Ok(m1) => {
                match m2{
                    Ok(m2) => {
                        m1.slerp(&m2, (t + t) * (T::one() - t))
                    }
                    Err(msg) => Err(msg)
                }
            }
            Err(msg) => Err(msg)
        }

    }
}
